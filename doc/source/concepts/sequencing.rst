.. _sequencing:

Sequencing
----------

Defining pulses using the :ref:`pulse template definition class structures <pulsetemplates>` yields a tree structure of :class:`.PulseTemplate` objects. To obtain a concrete pulse that can be executed, parameters have to be replaced by corresponding values and the object structure has to be converted into a sequence of waveforms (and possibly triggered jump annotations) that the hardware drivers can comprehend. This process is called *sequencing* in the qctoolkit. It converts :class:`.TablePulseTemplate` and :class:`.FunctionPulseTemplate` objects into a waveform representation by sampling voltage values along the time domain using the specified interpolation rules between table values or evaluating the defining function respectively. The tree structure arising from the use of :class:`.SequencePulseTemplate`, :class:`.RepetitionPulseTemplate`, :class:`.BranchPulseTemplate` and :class:`.LoopPulseTemplate` is converted into an intermediate instruction language consisting of four instructions: Execute a waveform (:class:`.EXECInstruction`), an unconditional goto to another instruction (:class:`.GOTOInstruction`), a conditional jump to another instruction (:class:`.JMPInstruction`) and a stop command, halting execution (:class:`.STOPInstruction`).

This approach was inspired by translation of syntax trees to machine instructions in modern compilers and necessitated by the fact that the hardware requires sequential commands rather than convoluted object structures. The output of the sequencing process is a set of waveforms and a sequence of instructions. These will later be interpreted by hardware drivers which will configure the specific devices accordingly (assuming these are capable of the required functionality). If :class:`.BranchPulseTemplate` and :class:`.LoopPulseTemplate` are not used, the compiled instruction sequence will consist only of execution instructions followed by a stop instruction, which represents a simple sequence of waveforms to play back.

The sequencing process is performed by a :class:`.Sequencer` and started with a call to :meth:`.Sequencer.build`. :class:`.Sequencer` maintains a stack of :class:`.SequencingElement` objects (i.e. pulse templates) that still need to be translated. Pushing a pulse template to the stack using :meth:`.Sequencer.push` will cause :class:`.Sequencer` to translate it next. Translation works as follows: :class:`.Sequencer` pops the first element from the stack and calls its :meth:`.SequencingElement.build_sequence` method. In the case of a :class:`.TablePulseTemplate`, this adds an :class:`.EXECInstruction` referring to a :class:`.TableWaveform` to the instruction sequence. In the case of a :class:`.SequencePulseTemplate`, this simply adds all subtemplates to the sequencing stack such that they are translated next. :class:`.FunctionPulseTemplate` and :class:`.RepetitionPulseTemplate` act very similarly. :class:`.BranchPulseTemplate` and :class:`.LoopPulseTemplate` behave in a more complicated way due to their branching ability. :ref:`Read more on conditional branching <branching>`.

The sequencing process can be interrupted at any point, e.g., if some parameter value depends on measurements that are to be made in the preceding part of the pulse. In this case, the method :meth:`.SequencingElement.requires_stop` of the first stack element will return `true`. :class:`.Sequencer` then stops the translation and returns the instruction sequence generated so far. This can then be executed and measurement can be made. Afterwards, the sequencing process can be invoked again. :class:`.Sequencer` will resume where it was interrupted previously (with the first item that remained on the stack). :meth:`.Sequencer.has_finished` allows to check, whether the sequencing process was completed.

Sequencing Process Example
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. note:: Provide an exemplary sequencing run