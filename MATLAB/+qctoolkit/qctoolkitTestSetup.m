%% Setup
global plsdata
plsdata = struct( ...
	'path', 'Y:\Cerfontaine\Code\qc-tookit-pulses', ...
	'awg', struct('inst', [], 'hardwareSetup', []), ...
	'daq', struct('inst', []) ...
	);


%% Repetition 4 Channel charge pulse
% Wwritten by F. Wangelik and P. Cerfontaine, 23.02.2018


% Define table template for each iteration/step/measurement
part_pulse = py.qctoolkit.pulses.TablePT( ...
	  struct( ...
	    'W',      py.list({ {'(t_wait+t_meas)/sample_rate', 'W_fast*(x_start + i_x*x_step) + W_slow*(y_start + i_y*y_step)'} }), ...
	    'X',      py.list({ {'(t_wait+t_meas)/sample_rate', 'X_fast*(x_start + i_x*x_step) + X_slow*(y_start + i_y*y_step)'} }), ...
	    'Y',      py.list({ {'(t_wait+t_meas)/sample_rate', 'Y_fast*(x_start + i_x*x_step) + Y_slow*(y_start + i_y*y_step)'} }), ...
	    'Z',      py.list({ {'(t_wait+t_meas)/sample_rate', 'Z_fast*(x_start + i_x*x_step) + Z_slow*(y_start + i_y*y_step)'} }), ...
	    'marker', py.list({ {'(t_wait+t_meas)/sample_rate', 1} }) ...
	  ) ...
	);

first_pulse = py.qctoolkit.pulses.TablePT( ...
	  pyargs( ...
		 'entries', ...
	    struct( ...
  	    'W',      py.list({ {'(t_wait+t_meas)/sample_rate', 'W_fast*(x_start + i_x*x_step) + W_slow*(y_start + i_y*y_step)'} }), ...
  	    'X',      py.list({ {'(t_wait+t_meas)/sample_rate', 'X_fast*(x_start + i_x*x_step) + X_slow*(y_start + i_y*y_step)'} }), ...
  	    'Y',      py.list({ {'(t_wait+t_meas)/sample_rate', 'Y_fast*(x_start + i_x*x_step) + Y_slow*(y_start + i_y*y_step)'} }), ...
  	    'Z',      py.list({ {'(t_wait+t_meas)/sample_rate', 'Z_fast*(x_start + i_x*x_step) + Z_slow*(y_start + i_y*y_step)'} }), ...
	      'marker', py.list({ {'(t_wait+t_meas)/sample_rate', 1} }) ...
	    ), ...
			'measurements', ...
			py.list({ {'A', 't_wait/sample_rate', '(t_meas/sample_rate)*meas_time_multiplier'}, ...
			          {'B', 't_wait/sample_rate', '(t_meas/sample_rate)*meas_time_multiplier'} } ...
			) ...		
		) ...
	);

rep_pulse = py.qctoolkit.pulses.repetition_pulse_template.RepetitionPulseTemplate(part_pulse, 'meas_time_multiplier-1');
meas_pulse = py.qctoolkit.pulses.SequencePT(first_pulse, rep_pulse);

% Create loop templates for both iterations
x_loop = py.qctoolkit.pulses.loop_pulse_template.ForLoopPulseTemplate(meas_pulse, 'i_x', 'N_x');
y_loop = py.qctoolkit.pulses.loop_pulse_template.ForLoopPulseTemplate(x_loop, 'i_y', 'N_y');

% Start parameter mapping via mapping template
general_charge_scan = py.qctoolkit.pulses.MappingPT( ...
	  pyargs( ...
		  'template',  y_loop, ...
		  'identifier', 'charge_scan', ...
		  'parameter_mapping', struct('x_step', '(x_stop-x_start)/N_x', ...
                                  'y_step', '(y_stop-y_start)/N_y'), ...
		  'allow_partial_parameter_mapping', true ...
		) ...
  );

general_charge_scan = py.qctoolkit.pulses.repetition_pulse_template.RepetitionPulseTemplate( ...
	  pyargs( ...
	    'body', general_charge_scan, ...
	  	'repetition_count', 'rep_count', ...
	  	'identifier', 'general_charge_scan' ...
	  ) ...
  );

%%
qctoolkit.plot_pulse(general_charge_scan, struct('x_start', -1, 'x_stop', 1, 'N_x', 10, 't_meas', 1, ...
                    'W_fast', 1, 'W_slow', 0, ...
                    'X_fast', 1, 'X_slow', 0, ...
                    'Y_fast', 0, 'Y_slow', 1, ...
                    'Z_fast', 0, 'Z_slow', 1, ...
                   'y_start', -1, 'y_stop', 1, 'N_y', 10, 't_wait', 0, 'sample_rate', 2.3, 'meas_time_multiplier', 2, ...
                          'rep_count', 2), 100)
												
												
% 												from qctoolkit.serialization import FilesystemBackend, Serializer

%%
backend    = py.qctoolkit.serialization.FilesystemBackend(plsdata.path);
serializer = py.qctoolkit.serialization.Serializer(backend);


serializer.serialize(pyargs('serializable', general_charge_scan, 'overwrite', true))

